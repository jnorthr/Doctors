
    // =======================================================
    // Asciidoctor methods follow :
    /**
     * @param verbose true if you want the engine to display the template source file for debugging purposes
     */
    public renderAsciidoc(payload, binding)
    {
System.out.println("AsciidocTemplateEngine.renderAsciidoc(${payload.toString()})");
	ath.setIncludeHeaderFooter(true);
    	ath.loadContent(payload);
      ath.setNeedHeader(true);
      ath.setKeepUnknownPlaceholders(false);
      return ath.render();
    } // end of render

// createTemplate logic
        say("--- Start Of Text For AsciidocTemplateHelper ---");    

        AsciidocTemplateHelper ath = new AsciidocTemplateHelper();
        ath.setVerbose(true);
        ath.loadContent(script);
        ath.setIncludeHeaderFooter(true);
        ath.setKeepUnknownPlaceholders(false);
        def tx = ath.getRenderedPayload();

        // get a StringWriter
        def txou = ath.sendToWriter(tx);

        try 
 	{
            say("--- groovyShell.parse() tx size()+${tx.size()}---");    
  
            template.script = groovyShell.parse("AsciidocTemplateScript" + counter++ + ".groovy");
	    if (verbose) 
	    {
      	    	say("\n-- template.script source --");
            	say(template.script.toString());
            	say("\n-- template.script end --\n");
            } // end of if

        } 
	catch (Exception e) 
	{
	    def msg = "Failed to parse template script (your template may contain an error or has an unsupported expression): " + e.getMessage();
	    say msg;
            throw new GroovyRuntimeException(msg);
        }



        /**
         * Builds prefix chars for GString script content writing beginning """ to string writer
	 *
         * called from String parse(Reader reader)
         *
         * @param sw     a StringWriter to write expression content
        */
        private void startScript(StringWriter sw) 
        {
            sw.write("out.print(\"\"\"");
        } // end of startScript


        /**
         * Builds suffix chars for GString script so that it ends with """ to string writer
         *
         * called from String parse(Reader reader)
         *
         * @param sw     a StringWriter to write ending """ expression content
        */
        private void endScript(StringWriter sw) 
        {
            sw.write("\"\"\");\n");
            sw.write("\n/* Generated by AsciidocTemplateEngine */");
        } // end of endScript


        /**
         * Consumes GString script content writing it to string writer until it finds a } or EOF
         *
         * Used in the parse(Reader reader) logic above
         *
         * @param reader a reader for the template text
         * @param sw     a StringWriter to write expression content
         * @throws IOException if something goes wrong
        */
        private void processGSstring(Reader reader, StringWriter sw) throws IOException 
        {
  		say "AsciidocTemplateEngine.processGString()";

	        int c;
                while ((c = reader.read()) != -1) 
	        {
                	if (c != '\n' && c != '\r') 
			{
 	                   sw.write(c);
        	        } // end of if

                	if (c == '}') 
			{
	                    break;
        	        } // end of if
	        } // end of while
        } // end of processGSstring


        /**
         * Closes the currently open write and writes out the following text as a GString expression until it reaches an end %>.
         *
         * Used in the parse(Reader reader) logic above
         *
         * @param reader a reader for the template text
         * @param sw     a StringWriter to write expression content
         * @throws IOException if something goes wrong
        */
        private void groovyExpression(Reader reader, StringWriter sw) throws IOException 
        {
            sw.write('${');
            int c;

            while ((c = reader.read()) != -1) 
	    {
            	if (c == '%') 
		{
                	c = reader.read();
                    	if (c != '>') 
			{
                        	sw.write('%');
                    	} 
			else 
			{
	                        break;
        	        } // end of else
                } // end of if

                if (c != '\n' && c != '\r') 
		{
                    sw.write(c);
                } // end of if
            } // end of while

            sw.write('}');

        } // end of groovyExpression


        /**
         * Closes the currently open write and writes the following text as normal Groovy script code until it reaches an end %>.
         * Used in the parse(Reader reader) logic above
         *
         * @param reader a reader for the template text
         * @param sw     a StringWriter to write expression content
         * @throws IOException if something goes wrong
        */
        private void groovySection(Reader reader, StringWriter sw) throws IOException 
        {
            sw.write("\"\"\");");
            int c;
            while ((c = reader.read()) != -1) 
	    {
            	if (c == '%') 
		{
                	c = reader.read();
                    	if (c != '>') 
			{
	                        sw.write('%');
        	        } 
			else 
			{
                        	break;
                    	}  // end of else
                } // end of if

                /* Don't eat EOL chars in sections - as they are valid instruction separators.
                 * See http://jira.codehaus.org/browse/GROOVY-980
                 */
                // if (c != '\n' && c != '\r') {

                	sw.write(c);
                //}

            } // end of while

            sw.write(";\nout.print(\"\"\"");
        } // end of groovySection

// protected String parse(Reader reader) throws IOException 

                startScript(sw);
                int c;

                while ((c = reader.read()) != -1) 
        	{
                	if (c == '<') 
            		{
	                    reader.mark(1);
        	            c = reader.read();
                	    if (c != '%') 
              		    {
 				sw.write('<');
                        	reader.reset();
                    	    } // end of if 
		            else 
		            {
                        	reader.mark(1);
                        	c = reader.read();
                        	if (c == '=') 
                		{
                            		groovyExpression(reader, sw);
                        	}
		                else 
                		{
                            		reader.reset();
                            		groovySection(reader, sw);
                        	} // end of else
                    	    } // end of else

	                    continue; // at least '<' is consumed ... read next chars.
                	} // end of if


	                if (c == '$') 
			{
                    		reader.mark(1);
                    		c = reader.read();
                    		if (c != '{') 
				{
                        		sw.write('$');
                        		reader.reset();
                    		} 
				else 
				{
		                        reader.mark(1);
                		        sw.write('${');
                        		processGSstring(reader, sw);
                    		} // end of else

		                continue; // at least '$' is consumed ... read next chars.
                	} // end of if

	                if (c == '\"') 
			{
        	            sw.write('\\');
                	} // end of if

	                /*
        	         * Handle raw new line characters.
                	*/
                	if (c == '\n' || c == '\r') 
			{
				if (c == '\r') 
				{                  // on Windows, "\r\n" is a new line.
                        		reader.mark(1);
                        		c = reader.read();
                        		if (c != '\n') 
					{
		                            reader.reset();
                        		} // end of if
                    		} // of if

		                sw.write('\n');
                    		continue;
                	} // end of if

	                sw.write(c);
            	} // end of while

	        endScript(sw);

// make()

		//say "AsciidocTemplateEngine.make(${map})"
		return new Writable() {
	                /**
        	         * Write the template document with the set binding applied to the writer.
                	 *
                 	 * @see groovy.lang.Writable#writeTo(java.io.Writer)
                 	 */
	                public Writer writeTo(Writer writer) 
			{
                    		Binding binding;
                    		binding = (map == null) ? new Binding() : new Binding(map); 

				say "\n\n==================\nScript hit:\n--------------------" 
                    
				try
				{   
					Script scriptObject = InvokerHelper.createScript(script.getClass(), binding); 
			  		say "\n--------------------\nAsciidocTemplateEngine.scriptObject=${scriptObject.toString()}";
                    			PrintWriter pw = new PrintWriter(writer);
		                  	scriptObject.setProperty("out", pw);
            		      		scriptObject.run();
                    			pw.flush();
			  		say "\n--------------------\nAsciidocTemplateEngine.pw.flush()\n--------------------";
			  	}
			  	catch(Exception x ) 
			  	{
					say "AsciidocTemplateEngine bad news:"+x.message
			  	} // end of catch

			        return writer;
	                } // end of writeTo



                    
				try
				{   
					Script scriptObject = InvokerHelper.createScript(script.getClass(), binding); 
			  		say "\n--------------------\nAsciidocTemplateEngine.scriptObject=${scriptObject.toString()}";
                    			PrintWriter pw = new PrintWriter(writer);
		                  	scriptObject.setProperty("out", pw);
            		      		scriptObject.run();
                    			pw.flush();
			  		say "\n--------------------\nAsciidocTemplateEngine.pw.flush()\n--------------------";
			  	}
			  	catch(Exception x ) 
			  	{
					say "AsciidocTemplateEngine bad news:"+x.message
			  	} // end of catch


